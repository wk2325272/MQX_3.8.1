/*HEADER****************************************************************
*
* Copyright (c) 2008-2009 Freescale Semiconductor;
* All Rights Reserved
*
* Copyright (c) 2004-2009 Embedded Access Inc.;
* All Rights Reserved
*
* Copyright (c) 1989-2008 ARC International;
* All Rights Reserved
*
***************************************************************************** 
*
* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
* THE POSSIBILITY OF SUCH DAMAGE.
*
***************************************************************************** 
*
* Comments:  This file was generated by "gawk -f def2c.awk" script.
*
*END*******************************************************************/

#include <rtcsrtos.h>
#include <rtcs.h>
#include "snmpcfg.h"
#include "asn1.h"
#include "snmp.h"


#if RTCSCFG_ENABLE_SNMP

extern RTCSMIB_NODE MIBNODE_enterprises;

extern RTCSMIB_NODE MIBNODE_your_company;
extern const RTCSMIB_NODE MIBNODE_mqx_demo;
extern const RTCSMIB_NODE MIBNODE_demo1;
extern const RTCSMIB_NODE MIBNODE_data;
extern const RTCSMIB_NODE MIBNODE_hello_string;
extern const RTCSMIB_NODE MIBNODE_counter;
extern const RTCSMIB_NODE MIBNODE_alarm_limit;
extern const RTCSMIB_NODE MIBNODE_traps;
extern const RTCSMIB_NODE MIBNODE_trapmsg1;

extern const RTCSMIB_VALUE MIBVALUE_your_company;
extern const RTCSMIB_VALUE MIBVALUE_mqx_demo;
extern const RTCSMIB_VALUE MIBVALUE_demo1;
extern const RTCSMIB_VALUE MIBVALUE_data;
extern const RTCSMIB_VALUE MIBVALUE_hello_string;
extern const RTCSMIB_VALUE MIBVALUE_counter;
extern const RTCSMIB_VALUE MIBVALUE_alarm_limit;
extern const RTCSMIB_VALUE MIBVALUE_traps;
extern const RTCSMIB_VALUE MIBVALUE_trapmsg1;



uint_32 MIB_set_alarm_limit         (pointer, uchar_ptr, uint_32);

RTCSMIB_NODE MIBNODE_your_company = {
   65534,

   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_mqx_demo,
   (RTCSMIB_NODE_PTR)&MIBNODE_enterprises,

   0,
   NULL,
   NULL, 0, NULL, NULL
};

const RTCSMIB_NODE MIBNODE_mqx_demo = {
   1,

   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_demo1,
   (RTCSMIB_NODE_PTR)&MIBNODE_your_company,

   0,
   NULL,
   NULL, 0, NULL, NULL
};

const RTCSMIB_NODE MIBNODE_demo1 = {
   1,

   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_data,
   (RTCSMIB_NODE_PTR)&MIBNODE_mqx_demo,

   0,
   NULL,
   NULL, 0, NULL, NULL
};

const RTCSMIB_NODE MIBNODE_data = {
   1,

   (RTCSMIB_NODE_PTR)&MIBNODE_traps,
   (RTCSMIB_NODE_PTR)&MIBNODE_hello_string,
   (RTCSMIB_NODE_PTR)&MIBNODE_demo1,

   0,
   NULL,
   NULL, 0, NULL, NULL
};

const RTCSMIB_NODE MIBNODE_hello_string = {
   1,

   (RTCSMIB_NODE_PTR)&MIBNODE_counter,
   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_data,

   RTCSMIB_ACCESS_READ,
   NULL,
   MIB_instance_zero, ASN1_TYPE_OCTET,
   (RTCSMIB_VALUE_PTR)&MIBVALUE_hello_string,
   NULL
};

const RTCSMIB_NODE MIBNODE_counter = {
   2,

   (RTCSMIB_NODE_PTR)&MIBNODE_alarm_limit,
   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_data,

   RTCSMIB_ACCESS_READ,
   NULL,
   MIB_instance_zero, ASN1_TYPE_INTEGER,
   (RTCSMIB_VALUE_PTR)&MIBVALUE_counter,
   NULL
};

const RTCSMIB_NODE MIBNODE_alarm_limit = {
   3,

   NULL,
   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_data,

   RTCSMIB_ACCESS_READ | RTCSMIB_ACCESS_WRITE,
   NULL,
   MIB_instance_zero, ASN1_TYPE_INTEGER,
   (RTCSMIB_VALUE_PTR)&MIBVALUE_alarm_limit,
   MIB_set_alarm_limit
};

const RTCSMIB_NODE MIBNODE_traps = {
   2,

   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_trapmsg1,
   (RTCSMIB_NODE_PTR)&MIBNODE_demo1,

   0,
   NULL,
   NULL, 0, NULL, NULL
};

const RTCSMIB_NODE MIBNODE_trapmsg1 = {
   1,

   NULL,
   NULL,
   (RTCSMIB_NODE_PTR)&MIBNODE_traps,

   RTCSMIB_ACCESS_READ,
   NULL,
   MIB_instance_zero, ASN1_TYPE_OCTET,
   (RTCSMIB_VALUE_PTR)&MIBVALUE_trapmsg1,
   NULL
};



#endif

#if ! RTCSCFG_ENABLE_SNMP
  #error This application requires RTCSCFG_ENABLE_SNMP defined non-zero in user_config.h. Please recompile BSP with this option.
#endif


/****************************************************************/
#include <mqx.h>
#include <bsp.h>

#include "snmp_demo.h"
#include "snmpcfg.h"
#include "snmp.h"

#define COUNTER_OVERFLOW    5
#define COUNTER_DELAY       5000

#define TRAP_SPEC   3

#define SEND_TRAP_V1    1
#define SEND_TRAP_V2    1

void MIBdemo_init(void);
static uint_32 i = 0;
static uint_32 alarm_limit = COUNTER_OVERFLOW;

void MIBdemo_init(void)
{
    RTCSMIB_mib_add(&MIBNODE_your_company);
}


uint_32 Get_timer( pointer dummy )
{
    return(i);
}

static void Set_timer( uint_32 value)
{
    i = value;
}

uint_32 Get_alarm_limit( pointer dummy )
{
    return(alarm_limit);
}

uint_32 MIB_set_alarm_limit (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
    int_32 varval = RTCSMIB_int_read(varptr, varlen);
    alarm_limit = varval;   
    return(0); /*SNMP_ERROR_noError;*/
} /* Endbody */

void Snmp_task( uint_32 temp )
{
    
    uint_32 j = 0;
    
    // show welcome screen on serial
    printf("\n\rSNMP demo started. You can change the counter value \
        through the SNMP protocol. \n\rCounter value: \n\r");
    for(;;)
    {
        printf("%d, ", i);
        _time_delay(COUNTER_DELAY);
        i++;                
        // test for alarm limit
        if(i > alarm_limit)
        {   
            // sned the alarm trap and clear counter
            #ifdef SEND_TRAP_V2
              SNMPv2_trap_userSpec( (RTCSMIB_NODE *)&MIBNODE_trapmsg1 );
            #endif
            #ifdef SEND_TRAP_V1
              SNMP_trap_userSpec( (RTCSMIB_NODE *)&MIBNODE_counter, TRAP_SPEC, 
                  (RTCSMIB_NODE *)&MIBNODE_your_company );
            #endif
            printf("\n\rTrap sent; Counter value:\n\r");
            Set_timer(0);
        }
    }
}

/****************************************************************/
const RTCSMIB_VALUE MIBVALUE_your_company = {
    RTCSMIB_NODETYPE_INT_CONST,
    NULL
};

const RTCSMIB_VALUE MIBVALUE_demo1 = {
    RTCSMIB_NODETYPE_INT_CONST,
    NULL
};

const RTCSMIB_VALUE MIBVALUE_mqx_demo = {
    RTCSMIB_NODETYPE_INT_CONST,
    NULL
};

const RTCSMIB_VALUE MIBVALUE_traps = {
    RTCSMIB_NODETYPE_INT_CONST,
    NULL
};
const RTCSMIB_VALUE MIBVALUE_data = {
    RTCSMIB_NODETYPE_INT_CONST,
    NULL
};

const RTCSMIB_VALUE MIBVALUE_hello_string = {
    RTCSMIB_NODETYPE_DISPSTR_PTR,
    (void _PTR_)"MQX SNMP demo"
};

const RTCSMIB_VALUE MIBVALUE_counter = {
    RTCSMIB_NODETYPE_UINT_FN,
    (void _PTR_)Get_timer
};

const RTCSMIB_VALUE MIBVALUE_alarm_limit = {
    RTCSMIB_NODETYPE_UINT_FN,
    (void _PTR_)Get_alarm_limit
};

const RTCSMIB_VALUE MIBVALUE_trapmsg1 = {
    RTCSMIB_NODETYPE_DISPSTR_PTR,
    (void _PTR_)"Counter reset"
};

/* EOF */
